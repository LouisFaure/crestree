{
    "collab_server" : "",
    "contents" : "#' @useDynLib crestree\nNULL\n\n##' Sample pptree objects using different seeds\n##' @param  n.samples a number of seed samplings.\n##' @param seeds a vector of seeds to use. Overwrites n.samples.\n##' @return a list of pptree objects\n##' @export\nmppt.tree <- function( ... , n.cores=30,n.samples=n.cores, seed=NULL,seeds=NULL) {\n  if(!is.null(seed)) {\n    set.seed(seed);\n  }\n  # sample seeds\n  if(is.null(seeds)) {\n    seeds <- round(runif(n.samples,0,.Machine$integer.max))\n  }\n  mclapply(seeds,function(i) ppt.tree(..., seed=i),mc.cores=n.cores)\n}\n\n##' Sample pptree objects using bootstrap\n##' @param X expression matrix of genes (rows) and cells (columns).\n##' @param M number of principal points of pptree.\n##' @param n.samples a number of seed samplings.\n##' @param replace sampling with replacement (logical).\n##' @return a list of pptree objects\n##' @export\nbootstrap.ppt <- function( ..., X, M=ncol(X),n.cores=20,n.samples=n.cores, seed=NULL,replace=T) {\n  if(!is.null(seed)) {\n    set.seed(seed);\n  }\n  parallel::mclapply(1:n.samples,function(i) {\n    # take a bootstrap sample\n    b.X <- X[,sample(1:ncol(X),M,replace=replace)];\n    ppt.tree(..., X=b.X, M=M, init=b.X)\n  },mc.cores=n.cores)\n}\n\n##' Calculate weighted pairwise correlations between columns of matrices A and B\n##' @export\ncor.mat <- function(A,B){\n  A1 <- t(t(A)-colMeans(A))\n  B1 <- t(t(B)-colMeans(B))\n  res <- (crossprod(A1,B1))/sqrt( tcrossprod(colSums(A1^2),(colSums(B1^2))) )\n  return(res)\n}\n\n##' Calculate pairwise euclidean distances between columns of matrices A and B\neuclidean.mat <- function(A,B){\n  x <- do.call(cbind,rep(list(colSums(A^2)),ncol(B)))\n  y <- do.call(rbind,rep(list(colSums(B^2)),ncol(A)))\n  suppressWarnings(res <- sqrt(x + y - 2*crossprod(A,B)))\n  res[is.na(res) | is.nan(res)] <- 0\n  return(res)\n}\n\n##' calculate weighted correlation between columns of a matrix and a given vector\nwcr <- function(X,y,w){\n  w <- w/sum(w)\n  X1 <- X*w\n  y1 <- y*w\n  X2 <- t(t(X)-colSums(X1))\n  y2 <- y - sum(y1)\n\n  cv1 <- (y2*w)%*%X2\n  cv2 <- sqrt(colSums(X2^2*w)*sum(y2^2*w))\n  cvv <- cv1/cv2\n  return(cvv[1,])\n}\n\n##' Reconstruction of the tree\n##'\n##' Using SimplePPT approach to model principal tree (pptree) of the data\n##' @name ppt.tree\n##' @param X gene (row) vs cell (columns) expression matrix\n##' @param emb embdedding to visalize cells and principal tree together\n##' @param M number of principal points to use (more than zero, no more than number of cells)\n##' @param init matrix of initial gene coordinates of principal points\n##' @param plot plot or not intermediate trees\n##' @param lambda penalty for the tree  length, as used in SimplePPT\n##' @param sigma parameter as used in SimplePPT\n##' @param seed used to make initial assignment of principal points to a subset of cells\n##' @param n.steps number of iteraions\n##' @param metrics metrics used to calculated distances between cells or principal points. \"euclidean\" or \"cosine\"\n##' @param p.power if cosine metrics used, option p.power allows to use (1-cor)^p.power (p.power=1 by default)\n##' @param err.cut stop algorithm if proximity of principal points between iterations less than err.cut\n##' @return pptree object\n##' @export\nppt.tree <- function(X,W=NA,emb=NA,M,init=NULL,plot=TRUE,output=TRUE,lambda=1e1,sigma=0.1,seed=NULL,n.steps=50,err.cut = 5e-2,metrics=\"cosine\",p.power=1,knn=NULL,...) {\n\n  if ( metrics!=\"euclidean\" & metrics!=\"cosine\" ){ stop(\"metrics paramterer is nethier 'euclidean' nor 'cosine'\") }\n  if ( M < 0 | M > ncol(X)) { stop(\"M should be more than zero and less or equal than the number of cells\") }\n  if (!is.na(emb)){\n    if ( sum(!colnames(X)%in%rownames(emb))>0 ) { stop(\"column names of gene expression matrix (X) are not consistent with row names of embedding (emb)\") }\n  }\n\n  X <- as.matrix(X)\n  wt <- TRUE\n  if (is.na(W)) {\n    wt <- FALSE\n    W <- matrix(1,nrow=nrow(X),ncol=ncol(X))\n  }else{\n    W <- as.matrix(W[rownames(X),colnames(X)])\n  }\n\n  if(is.null(init)){\n    if(!is.null(seed)){\n      set.seed(seed);\n    }\n    F.mat <- X[,sample(1:ncol(X),M)]; rownames(F.mat) <- NULL; colnames(F.mat) <- NULL;\n  } else {\n    F.mat <- init;\n  }\n\n  # row-normalize W\n  rwm <- matrix(rowSums(W),nrow=nrow(F.mat),ncol(F.mat))\n  W <- W/rowSums(W)*ncol(W);\n\n\n  # repeat untile convergence\n  j=1; err=100;\n  while(j <= n.steps & err > err.cut) {\n    # calculate R\n    if (metrics==\"euclidean\"){\n      # simple correlation or column-wise weighted correlation.\n      if (wt==FALSE) {\n        R <- euclidean.mat(F.mat,X)^p.power\n      }else{\n        R <- do.call(cbind,lapply(1:ncol(X),function(i) {\n          sqrt(colSums(((F.mat-X[,i])^2)*W[,i]))^p.power\n        }))\n      }\n      R <- t(exp(-R/sigma))\n    }else if(metrics==\"cosine\"){\n      # simple correlation or column-wise weighted correlation.\n      if (wt==FALSE) {\n        cordist <- (1-cor.mat(F.mat,X))^p.power\n      }else{\n        cordist <- do.call(cbind,lapply(1:ncol(X),function(i) {\n            (1-matWVCorr(F.mat,X[,i],W[,i]))^p.power\n            #(1-wcr(F.mat,X[,i],W[,i]))^p.power\n        }))\n        colnames(cordist) <- colnames(X)\n      }\n\n      cordist <- (cordist-mean(cordist))\n      R <- t(exp( -(cordist)/sigma ))\n    }\n    R[is.na(R) | is.nan(R)] <- 0\n    if (!is.null(knn)){\n      R = apply(R,2,function(x){\n        x[ x < sort(x,decreasing = TRUE)[knn] ] <- 0\n        x\n      })\n    }\n    R <- R/rowSums(R)\n    R[is.na(R) | is.nan(R)] <- 0\n\n    # calculate distance between principal points\n    if (metrics==\"euclidean\"){\n      d <- euclidean.mat(F.mat,F.mat)\n    }else if (metrics==\"cosine\"){\n      if (wt==FALSE) {\n        d <-  1-cor.mat(F.mat,F.mat)\n      }\n      else{\n        d <- do.call(cbind,lapply(1:ncol(F.mat),function(i) {\n          (1-matWVCorr(F.mat,F.mat[,i],rwm[,i]))^p.power\n          #(1-wcr(F.mat,F.mat[,i],rwm[,i]))^p.power\n        }))\n      }\n      d <- abs(d)^p.power*sign(d)\n    }\n    bt <- minimum.spanning.tree(graph.adjacency(as.matrix(d),weighted=T,mode=\"undirected\"))\n\n    B <- as.matrix(get.adjacency(bt))\n    D <- diag(nrow(B))*rowSums(B)\n    L <- D-B\n    M <- L*lambda + diag(ncol(R))*colSums(R)\n\n    old.F <- F.mat;\n    #F.mat <- (X%*%R) %*% chol2inv(chol(M))\n    F.mat <- t(solve( t(M),t((X*W)%*%R) ))# slightly faster, 15%\n    F.mat <- as.matrix(F.mat)\n\n    if (plot==TRUE){plotppt(list(F=F.mat,B=B,R=R,L=L,lambda=lambda,sigma=sigma),emb,...)}\n\n    if (output==TRUE){\n      cat(j,\":\")\n      cat(\"\\n\")\n      err = max(sqrt(colSums(F.mat-old.F)^2)/apply(F.mat,2,function(x)sqrt(sum(x^2))))\n      cat(err,\"\\n\")\n    }\n    j=j+1\n  }\n\n  if (plot==TRUE){plotppt(list(F=F.mat,B=B,R=R,L=L,lambda=lambda,sigma=sigma),emb,...)}\n\n  g = graph.adjacency(B,mode=\"undirected\");tips = V(g)[degree(g)==1];forks = V(g)[degree(g)>2]\n\n  score = c( sum( t(1-cor.mat(F.mat,X))*R)/nrow(R), sigma/nrow(R)*sum(R*log(R),na.rm=T),lambda/2*sum(d*B))\n\n  colnames(R) <- colnames(F.mat) <- rownames(B) <- colnames(B) <- as.character(1:nrow(B))\n  invisible(list(score=score,F=F.mat,B=B,R=R,L=L,DT=d,lambda=lambda,sigma=sigma,n.steps=n.steps,metrics=metrics,M=M,cells=vi,tips=tips,forks=forks))\n}\n\n\n##' Estimate optimal sigma parameter.\n##'\n##' Using cross-validation criteria to select sigma parameter.\n##' @param X gene (rows) vs cell (columns) expression matrix\n##' @param M number of principal points in pptree modeling\n##' @param n.sample number of sampled trees per each sigma\n##' @param sig.lims a vector of sigma for which cross-validation estimated\n##' @param metrics similarity measure. \"cosine\" or \"euclidean\"\n##' @return optimal sigma parameter\n##' @export\nsig.explore <- function(X,W=NA,M=as.integer(ncol(X)/2),n.sample=1,sig.lims=seq(0.01,0.2,0.03),metrics=\"cosine\",p.power = 1,plot=TRUE,err.cut=5e-1,n.steps=20,n.cores=1){\n  if (is.na(X)) {stop(\"matrix X should be specified\")}\n  if (is.na(M)) {stop(\"number of principal points M should be specified\")}\n  cells <- colnames(X)\n  for (i in 1:n.sample){\n    cv <- do.call(rbind,mclapply(sig.lims,function(sig){\n      x <- ppt.tree(X = X,W,M=M,err.cut=err.cut,metrics=metrics,n.steps=n.steps,p.power = p.power,lambda=0,sigma=sig,plot=FALSE,output=FALSE,seed=sample(100,1))\n      y <- cor(X,x$F)\n      apply(y,1,max)\n    },mc.cores = n.cores))\n    if (i==1){\n      cv.tot <- cv\n    }\n    else{\n      cv.tot <- cv.tot + cv\n    }\n  }\n  cv.tot <- cv.tot/n.sample\n\n  sig.opt <- sig.lims[which.max(apply(cv.tot,1,mean))]\n  if (plot==TRUE){\n    par(mfrow=c(1,1),mar=c(5,5,1,1))\n    plot( sig.lims, apply(cv.tot,1,mean),lty=2,lwd=2,type=\"l\",xlab=\"sigma\",ylab=\"CV\",cex.lab=1.5)\n    points( sig.lims, apply(cv.tot,1,mean),pch=19,cex=1)\n    abline(v=sig.opt,col=\"red\",lty=2)\n  }\n  #return( cbind(sig.lims,apply(cv.tot,1,mean)) )\n  return(sig.opt)\n\n}\n\n##' Explore lambda\n##'\n##' Explores multiple lambda and choose the optimal\n##' @param X gene (rows) vs cell (columns) expression matrix\n##' @param M number of principal points in pptree modeling\n##' @param sigma fixed parameter sigma used in pptree modeling\n##' @param emb embdedding to visalize cells and principal tree together. If emb is given than pptrees for a range of lambda are shown\n##' @export\nlambda.explore <- function(X=NA,M=ncol(X),sigma=0.1,emb=NA,metrics=\"cosine\",tips.min=2,tips.max=20,base=2,lambda.init=100,err.cut=5e-3,n.steps=40,p.power=1){\n  if (is.na(X)) {stop(\"matrix X should be specified\")}\n  if (is.na(M)) {stop(\"number of principal points M should be specified\")}\n  cells <- colnames(X)\n\n  min.reached <- FALSE;max.reached <- FALSE\n  lambda <- round(lambda.init)\n  tr.list <- list()\n  while (min.reached==FALSE | max.reached==FALSE){\n    print(paste(\"lambda:\",round(lambda,2) ))\n    tr <- ppt.tree(X=X,M=M,lambda=lambda,sigma=sig,err.cut=err.cut,metrics=metrics,n.steps=n.steps,p.power = p.power,plot=FALSE,output=FALSE,seed=sample(100,1))\n    tr <- setroot(tr,root=as.character(tr$tips[1]))\n    tr.list[[as.character(round(lambda,1))]] <- tr#c(tr.list,tr)\n\n    tips <- length(tr$tips);\n    len <- sum(tr$pp.segments$d)\n    entropy.ind <- sum(tr$pp.segments$d*log(tr$pp.segments$d))\n     # add entry to the lambda.info matrix\n    if (lambda == lambda.init){\n      lambda.info <- matrix(c(lambda=lambda,tips=tips,length=len,entropy=entropy.ind),nrow=1,ncol=4)\n      #tr.list[[as.character(lambda)]] <- tr\n    }else{\n      if (lambda < lambda.info[1,1]){\n        lambda.info <- rbind(c(lambda=lambda,tips=tips,length=len,entropy=entropy.ind),lambda.info)\n        #tr.list[[as.character(lambda)]] <- tr#c(tr,tr.list)\n      }else{\n        lambda.info <- rbind(lambda.info,c(lambda=lambda,tips=tips,length=len,entropy=entropy.ind))\n        #tr.list[[as.character(lambda)]] <- #c(tr.list,tr)\n      }\n    }\n    # update lambda\n    if (min.reached == FALSE & tips < tips.max){\n      lambda <- lambda/base\n    }else if (min.reached == FALSE & tips >= tips.max){\n      min.reached <- TRUE\n      lambda <- lambda.info[nrow(lambda.info),1]*base\n    }else if (tips <= tips.min ){# | tips >= lambda.info[nrow(lambda.info)-1,2]){\n      max.reached <- TRUE\n    }else{\n      lambda <- lambda.info[nrow(lambda.info),1]*base\n    }\n  }\n\n  ent.per.tip <- lambda.info[,4]/lambda.info[,2]\n  i.opt <- which.min(ent.per.tip)\n  if (!is.na(emb)){\n    par(mfrow=c(2,2))\n    par(mar=c(5,5,1,1))\n    plot( lambda.info[,1], ent.per.tip,lty=2,lwd=2,type=\"l\",xlab=\"lambda\",ylab=\"entropy per tip\",cex.lab=1.5)\n    points(lambda.info[,1], ent.per.tip,pch=19,cex=1)\n    abline(v=lambda.info[i.opt,1],col=\"red\",lty=2)\n    par(mar=rep(1,4))\n    lamb <- lambda.info[i.opt,1]; lamb <- round(lamb,1)\n    plotppt(tr.list[[as.character(lamb)]],emb,cex.tree = 0.1,lwd.tree = 3,main=paste(\"lambda =\",lamb))\n    box(col=\"red\",lwd=3);\n    lamb <- lambda.info[median(1:i.opt),1]; lamb <- round(lamb,1)\n    plotppt(tr.list[[as.character(lamb)]],emb,cex.tree = 0.1,lwd.tree = 3,main=paste(\"lambda =\",lamb))\n    lamb <- lambda.info[median((i.opt+1):nrow(lambda.info)),1]; lamb <- round(lamb,1)\n    plotppt(tr.list[[as.character(lamb)]],emb,cex.tree = 0.1,lwd.tree = 3,main=paste(\"lambda =\",lamb))\n  }\n  return(lambda.info)\n  #return(list(lambda.info[i.opt,1],lambda.info))\n}\n\n\n##' Visualize pptree onto embedding\n##'\n##' Projects pptree onto embedding (e.g. tSNE)\n##' @name plotppt\n##' @param r - pptree object\n##' @param emb - (x,y) coordinates data frame (e.g Rtsne $Y result)\n##' @param F - coordinates of principal points (optional)\n##' @param gene - a gene to show expression of (optional)\n##' @param mat - gene vs cell expression matrix (needed if option 'gene' is activated)\n##' @param pattern.cell - numeric profile of a quantity for each cell (e.g. expression of a gene or cell cycle stage)\n##' @param pattern.tree - numeric profile of a quantity for each principal point (e.g. expression of a gene or cell cycle stage)\n##' @param cex.main - cex of points\n##' @param cex.col - color of points\n##' @param cex.title - cex of title\n##' @param cex.tree - cex of principal points\n##' @param tips - logical, to draw indecies of tips of the tree. Usefull before usage of cleanup.branches()\n##' @export\nplotppt <- function(r,emb,F=NULL, gene=NULL, main=gene, mat=NULL, pattern.cell=NULL, pattern.tree=NULL,\n                       cex.col=NA, tree.col = NULL,\n                       cex.main=0.5, cex.title=1,\n                       cex.tree=1.5,lwd.tree=1,par=TRUE,tips=FALSE,forks=FALSE,subtree=NA,...) {\n  if ( sum(!rownames(r$R)%in%rownames(emb))>0 ) { stop(\"cell names used for tree reconstruction are not consistent with row names of embedding (emb)\") }\n  if (sum(!is.na(cex.col))==0 ) {cex.col=rep(\"grey70\",nrow(emb)); names(cex.col) <- rownames(emb)}\n  vi = rownames(emb)%in%rownames(r$R); names(vi) <- rownames(emb)\n  if(is.null(F)) { F <- t(t(t(emb[rownames(r$R),])%*%r$R)/colSums(r$R)) }\n  if ( is.null(pattern.cell) & !is.null(gene) ){\n    if (is.null(mat)) { stop(\"mat expression matrix should be defined together with gene parameter\") }\n    if (gene %in% rownames(mat) == FALSE) { stop(\"gene is not in mat matrix\") }\n    if ( sum(!rownames(r$R) %in% colnames(mat)) > 0 ) { stop(\"cell names used for tree reconstruction are not consistent with mat column names\") }\n    pattern.cell = mat[gene,rownames(r$R)]#mat[gene,rownames(r$R)]\n  }\n\n  if ( !is.null(pattern.tree) & length(pattern.tree) != ncol(r$R) ) { stop(\"length of pattern.tree vector is inconsistent with cell number used for tree reconstruction\") }\n  if ( !is.null(pattern.cell) & is.null(pattern.tree) ){\n    if ( sum(!names(pattern.cell) %in% rownames(r$R)) > 0 ){ stop(\"pattern.cell vector should contain names for all cells used to reconstruct the tree\")}\n    pattern.cell <- pattern.cell[rownames(r$R)] ## is it correct?\n    aggr <- colSums(r$R)\n    pattern.tree <- t(r$R)%*%pattern.cell[rownames(r$R)]/aggr\n    pattern.tree[aggr==0] <- NA\n  }\n\n  if (is.null(tree.col)) {tree.col = \"black\"}\n  if( !is.null(pattern.cell) ){\n    cex.col <- rep(\"black\",nrow(emb)); names(cex.col) <- rownames(emb)\n    cex.col[names(pattern.cell)] <- colorRampPalette(c(\"blue\",\"gray50\",\"red\"))(1024)[round((pattern.cell-min(pattern.cell))/diff(range(pattern.cell))*1023)+1]\n    #cex.col <- colorRampPalette(c(\"blue\",\"gray50\",\"red\"))(1024)[round((pattern.cell-min(pattern.cell))/diff(range(pattern.cell))*1023)+1]\n  }\n  if ( !is.null(pattern.tree) ){\n    tree.col <- colorRampPalette(c(\"blue\",\"gray50\",\"red\"))(1024)[round((pattern.tree-min(pattern.tree,na.rm=T))/diff(range(pattern.tree,na.rm = T))*1023)+1]\n    #r$fitting$pp.fitted[gene,]\n  }\n\n  if (!is.na(subtree)){\n    cex.col[rownames(r$cell.summary)][!r$cell.summary$seg %in% subtree$seg] <- \"black\"\n    #tree.col[rownames(r$pp.info)][!r$pp.info$seg %in% subtree$seg] <- \"black\"\n    tree.col[!r$pp.info$seg %in% subtree$seg] <- \"grey80\"\n    vi[vi==TRUE][rownames(r$cell.summary)][!r$cell.summary$seg %in% subtree$seg] <- FALSE\n  }\n\n  if ( sum(names(cex.col)%in%rownames(emb))==0 ) {stop('cex.col names do not match row names of emb')}\n\n  cols <- rep(\"black\",nrow(emb)); names(cols) <- rownames(emb)\n  cols[ intersect(names(cex.col),rownames(emb)) ] <- cex.col[intersect(names(cex.col),rownames(emb))]\n  if (par==TRUE) {par(mar=rep(1,4))}\n  plot(emb,pch=ifelse(vi,19,1),cex=cex.main,col = adjustcolor(cols,ifelse(is.null(pattern.tree),1,0.1)),xlab=NA,ylab=NA,xaxt='n',yaxt='n',main=main,cex.main=cex.title,font.main=1)\n\n  al <- get.edgelist(graph.adjacency(r$B>0))\n  al <- matrix(as.integer(al),ncol=2)\n  segments(F[1,al[,1]],F[2,al[,1]],F[1,al[,2]],F[2,al[,2]],lwd=lwd.tree)\n  points(t(F),pch=21,\n         col=tree.col,bg=tree.col,cex=cex.tree)\n\n  if (tips==TRUE){\n    coord = do.call(rbind,lapply(r$tips,function(tip){\n      x1 = F[1,tip]; y1 = F[2,tip]\n      x2 = F[1,which(r$B[tip,]>0)]; y2 = F[2,which(r$B[tip,]>0)]\n      xnew = x1 + 1.5*sign(x1-x2)#(1+sign(x1-x2)/0.5)*sign(x1-x2)#alpha*(x1-x2)\n      ynew = y1 + 1.5*sign(y1-y2)#xnew*(y2-y1)/(x2-x1) + (y1*x2-y2*x1)/(x2-x1)\n      c(xnew,ynew)\n    }))\n    text((coord),col=1,cex=1,adj=c(0,0),labels=r$tips,font=2);#text(t(F[, r$tips ]),col=1,cex=1.2,adj=c(0,0),labels=r$tips);\n  }\n  if (forks==TRUE & length(r$forks) > 0){\n    coord = do.call(rbind,lapply(r$forks,function(fork){\n      x1 = F[1,fork]; y1 = F[2,fork]\n      x2 = F[1,which(r$B[fork,]>0)]; y2 = F[2,which(r$B[fork,]>0)]\n      xnew = x1 #+ 1.5*sign(x1-x2)#(1+sign(x1-x2)/0.5)*sign(x1-x2)#alpha*(x1-x2)\n      ynew = y1 #+ 1.5*sign(y1-y2)#xnew*(y2-y1)/(x2-x1) + (y1*x2-y2*x1)/(x2-x1)\n      c(xnew,ynew)\n    }))\n    text((coord),col=1,cex=1,adj=c(0,0),labels=r$forks,font=2);#text(t(F[, r$tips ]),col=1,cex=1.2,adj=c(0,0),labels=r$tips);\n  }\n  #legend(x=\"bottomright\",legend=c(paste(\"lambda=\",r$lambda[1],sep=\"\"),paste(\"sigma=\",r$sigma[1],sep=\"\")))\n}\n\n\n##' Visualize list of pptree objects onto embedding\n##'\n##' Projects pptree objects onto embedding (e.g. tSNE)\n##' @param rl list of pptree objects (as calculated using bootstrap.tree or mppt.tree)\n##' @param emb (x,y) coordinates data frame (e.g Rtsne $Y result)\n##' @param cols vector of colors for cells in emb.\n##' @export\nplotpptl <- function(rl,emb, cols=adjustcolor(1,alpha=0.3),alpha=1, lwd =1, ...) {\n  par(mfrow=c(1,1), mar = c(3.5,3.5,2.0,0.5), mgp = c(2,0.65,0), cex = 0.8);\n  plot(emb,col=cols,cex=1,pch=19,xlab=\"\",ylab=\"\", ...)\n  lapply(rl,function(r) {\n    F <- t(t(t(emb[rownames(r$R),])%*%r$R)/colSums(r$R))\n    al <- get.edgelist(graph.adjacency(r$B>0))\n    al <- matrix(as.integer(al),ncol=2)\n    #points( t(F),col=adjustcolor(cols,alpha=0.1),lwd=1,cex=0.2 )\n    segments(F[1,al[,1]],F[2,al[,1]],F[1,al[,2]],F[2,al[,2]],lwd=lwd,col=adjustcolor(\"black\",alpha))\n  })\n  #legend(x=\"bottomright\",legend=c(paste(\"lambda=\",rl[[1]]$lambda[1],sep=\"\"),paste(\"sigma=\",rl[[1]]$sigma[1],sep=\"\")))\n}\n\n\n##' Remove spurious branches of pptree\n##' @param r ppt.tree result\n##' @param tips.number select and retain only fixed number of tips (tips.number) that explain the most cell-cell variation.\n##' @param tips.remove vector of tips indices to remove\n##' @param min.branch.length remove all branches with length less or equal than min.branch.length principal points\n##' @param min.dist.length remove all branches with length less or equal than min.dist.length principal points\n##' @return modified ppt.tree object with cleaned up structure\n##' @export\ncleanup.branches <- function(r,tips.number=NULL,tips.remove=NULL,min.branch.length=3,min.dist.length=NA) {\n\n  if (!is.null(tips.remove)){\n    if (sum(!tips.remove %in% r$tips) > 0) { stop(\"tips from tips.remove are not consistent with annotation of the tree tips\") }\n  }else{\n    tips.remove <- c()\n  }\n\n  #if (!is.null(min.branch.length)){\n  #  g <- graph.adjacency(r$B,mode=\"undirected\")\n  #  leaves <- V(g)[degree(g)==1]\n  #  branches <- V(g)[degree(g)>2]\n  #  bd <-shortest.paths(g,v=leaves,to=branches)\n  #  tips.remove <- c(tips.remove,leaves[which( apply(bd,1,min) < min.branch.length)])\n  #}\n  if (!is.null(min.dist.length)){\n    if (r$metrics==\"euclidean\"){\n      d <- euclidean.mat(r$F,r$F)\n    }else if (r$metrics==\"cosine\"){\n      d <-  1-cor.mat(r$F,r$F)\n      d <- abs(d)\n    }\n    g <- graph.adjacency(r$B*d,mode=\"undirected\",weighted = TRUE)\n    leaves <- V(g)[degree(g)==1]\n    branches <- V(g)[degree(g)>2]\n    bd <-shortest.paths(g,v=leaves,to=branches)\n    tips.remove <- c(tips.remove,leaves[which( apply(bd,1,min) < min.dist.length)] )\n  }\n  tips.retain = as.numeric(setdiff(r$tips,(tips.remove)))\n  #print(paste(\"tips: \",leaves))\n  #print(paste(\"remove: \",tips.remove))\n  #print(paste(\"retain: \",tips.retain))\n\n  if (!is.null(tips.number)){\n    if (length(tips.remove)+tips.number > length(r$tips)) { stop(\"number of tips to remove is higher than the number of tips in the tree\") }\n    g <- graph.adjacency(r$B,mode=\"undirected\",weighted = TRUE)\n    x = unlist(lapply( 1:2^length(tips.retain),function(i){\n      base.bin = decompose(i)\n      if (length(base.bin)==tips.number){\n        tps <- as.numeric(tips.retain[base.bin+1])\n        bd <- get.shortest.paths(g,tps[1],to=tps[-1])\n        pps.sub <- unique(unlist(bd$vpath))\n        sum(r$R[,pps.sub])\n      }else{NA}\n    }))\n    tips.retain = tips.retain[decompose(which(x == max(x,na.rm=TRUE)))+1]\n  }\n\n  g <- graph.adjacency(r$B,mode=\"undirected\")\n  bd <- get.shortest.paths(g,tips.retain[1],to=tips.retain[-1])\n  pps.sub <- unique(unlist(bd$vpath))\n  # remove from the graph (B)\n  r$B <- r$B[pps.sub,pps.sub]\n  # remove from F\n  r$F <- r$F[,pps.sub];\n  # remove from R and renormalize\n  r$R <- r$R[,pps.sub];\n  r$R <- r$R/rowSums(r$R); #r$R[is.na(r$R)|is.nan(r$R)] <- 0\n  # remove from DT\n  r$DT <- r$DT[pps.sub,pps.sub];\n  rownames(r$DT) <- colnames(r$DT) <- colnames(r$F) <- colnames(r$B) <- rownames(r$B) <- as.character(1:nrow(r$B));\n\n  if (!is.null(min.branch.length)){\n    small.branches <- TRUE\n    while (small.branches==TRUE){\n      # find a tip with length of <= min.branch.length\n      g <- graph.adjacency(r$B,mode=\"undirected\")\n      leaves <- V(g)[degree(g)==1]\n      branches <- V(g)[degree(g)>2]\n      bd <-shortest.paths(g,v=leaves,to=branches)\n      if ( sum(apply(bd,1,min) < min.branch.length)==0 ) {\n        small.branches=FALSE\n      }else{\n        # remove the tip from the tree\n        tip.remove <- leaves[which( apply(bd,1,min) < min.branch.length)][1]\n        tips.retain <- setdiff(leaves,tip.remove)\n        bd <- get.shortest.paths(g,tips.retain[1],to=tips.retain[-1])\n        pps.sub <- unique(unlist(bd$vpath))\n        r$B <- r$B[pps.sub,pps.sub]; r$F <- r$F[,pps.sub];r$R <- r$R[,pps.sub];\n        #r$R <- r$R/rowSums(r$R); r$R[is.na(r$R)|is.nan(r$R)] <- 0\n      }\n    }\n  }\n\n  colnames(r$F) <- colnames(r$B) <- rownames(r$B) <- as.character(1:nrow(r$B));\n  g = graph.adjacency(r$B,mode=\"undirected\"); r$tips = V(g)[degree(g)==1];r$forks = V(g)[degree(g)>2]\n\n  r\n}\n\n##' Orient the tree by setting up the root\n##'\n##' Assign root, pseudotime and segment to each principal point of the tree\n##' @param r pptree object\n##' @param root root principal point (plotppt(tips=TRUE,..) can be used to visualize candidate tips for a root)\n##' @return modified ppt.tree object with new fields r$pp.info (estimated pseudotime and branch of principal points), r$pp.segments (segments information), r$root (root id).\n##' @export\nsetroot <- function(r,root=NULL,plot=TRUE) {\n  if (is.null(root)) { stop(\"Assign correct root number\") }\n  if ( ! root %in% r$tips ) {stop(\"Root should be one of the tree tips\")}\n  # calculate time of each PP\n  if (r$metrics==\"euclidean\"){d <- 1e-6+euclidean.mat(r$F,r$F)\n  }else if (r$metrics==\"cosine\"){\n    d <-  abs( 1e-2 + 1-cor.mat(r$F,r$F))\n  }\n  g <- graph.adjacency(r$B*d,weighted=T,mode=\"undirected\")\n  pp.info <- data.frame( cbind( V(g),as.double(shortest.paths(g,root,V(g))),rep(0,length(V(g))) ));\n  colnames(pp.info)=c(\"PP\",\"time\",\"seg\")\n\n  # infer all segments (and put in segs) of the tree\n  nodes <- V(g)[ degree(g)!=2 ]\n  pp.segs = data.frame(n=numeric(),from=character(),to=character(),d=numeric())\n  for (i in 1:(length(nodes)-1) ){\n    for (j in (i+1):length(nodes)){\n      node1 = nodes[i];node2=nodes[j];\n      path12 = unlist(get.shortest.paths(g,from=as.character(node1),to=as.character(node2)))\n      if ( sum(nodes %in% path12) == 2  ) {\n        from = node1$name;to=node2$name\n        if ( !is.null(root)){\n          path_root = shortest.paths(g,root,c(node1,node2))\n          from = colnames(path_root)[which.min(path_root)]\n          to = colnames(path_root)[which.max(path_root)]\n        }\n        pp.info[path12,]$seg = nrow(pp.segs)+1\n        pp.segs=rbind(pp.segs,data.frame(n=nrow(pp.segs)+1,from=from,to=to,d=shortest.paths(g,as.character(node1),as.character(node2))[1]))\n      }}}\n  pp.segs$color=rainbow(nrow(pp.segs))\n  pp.info$color=pp.segs$color[pp.info$seg]\n\n  r$pp.segments <- pp.segs;\n  r$root <- root;\n  r$pp.info <- pp.info\n  r\n}\n\n\n\n##' Project cells onto the principal tree\n##' @param r pptree object\n##' @param emb if not NULL than cell branch assignment and color code of branches are shown\n##' @param n.mapping number of probabilistic mapping of cells onto the tree to use. If n.mapping=1 then likelihood cell mapping is used.\n##' @return modified pptree object with new fields r$cell.summary, r$cell.info and r$img.list. r$cell.summary contains information about cells projected onto the tree, including pseudotime and branch.\n##' @export\nproject.cells.onto.ppt <- function(r,emb=NULL,n.mapping=1) {\n  if (is.null(r$root)) { stop(\"Assign root first\") }\n\n  g <- graph.adjacency(r$B,weighted=TRUE,mode=\"undirected\")\n\n  df.list <- lapply(1:n.mapping,function(nm){\n    print(paste(\"mapping\",nm))\n    # assign nearest principal point for each cell\n    if (nm > 1){\n      rrm = apply(r$R,1,function(v){sample(1:length(v),size=1,prob=v/sum(v))})\n    }else{\n      rrm <- apply(r$R,1,which.max)\n    }\n\n    # idenfity edge onto which each cell lies\n    df <- do.call(rbind,lapply(1:ncol(r$R),function(v) {\n      vcells <- which(rrm==v);\n      if(length(vcells)>0) {\n        # determine which edge the cells belong to neighboring PPs\n        nv <- as.integer(neighborhood(g,1,nodes=c(v))[[1]])\n        nvd <- shortest.paths(g,v,nv)\n        spi <- apply(r$R[vcells,nv[-1],drop=FALSE],1,which.max)+1\n        ndf <- data.frame(cell=vcells,v0=v,v1=nv[spi],d=nvd[spi])\n        p0 <- r$R[vcells,v]\n        p1 <- unlist(lapply(1:length(vcells),function(i) r$R[vcells[i],ndf$v1[i]] ))\n        alpha <- runif(length(vcells))\n        f <- abs( (sqrt(alpha*p1^2+(1-alpha)*p0^2)-p0)/(p1-p0) )\n        ndf$t <- r$pp.info[ndf$v0,]$time+(r$pp.info[ndf$v1,]$time-r$pp.info[ndf$v0,]$time)*alpha\n        ndf$seg <- r$pp.info[ndf$v0,]$seg\n        ndf$color <- r$pp.info[ndf$v0,]$color\n        ndf\n      } else {\n        return(NULL);\n      }\n    }))\n    df$edge <- apply(df,1,function(x) paste(sort(as.numeric(x[c(2,3)])),collapse=\"|\"))\n    df <- df[order(df$t,decreasing=FALSE),]\n    # make graph from cells and PPs\n    return(df)\n  })\n\n  # generate graph of cells and PPs for each mapping\n  img.list <- lapply(df.list,function(df){\n    img <- g#graph.adjacency(r$B,weighted=TRUE,mode=\"undirected\")\n    img <- set.vertex.attribute(img,\"type\",value=\"pp\")\n    for(e in unique(df$edge)){\n      ii <- which(df$edge==e);\n      vc <- as.integer(strsplit(e,'\\\\|')[[1]]);\n      imin <- which.min(r$pp.info$time[vc])\n      #print(imin)\n      #imin <- 1\n      #print(c(imin,3-imin))\n      # insert the cells\n      if (imin==1){\n        img <- add_vertices(img,length(ii),type=\"cell\",name=paste('c',df[ii,]$cell,sep=''))\n      }else{\n        img <- add_vertices(img,length(ii),type=\"cell\",name=paste('c',rev(df[ii,]$cell),sep=''))\n      }\n      tw <- 1-E(g,path=c(vc[1],vc[2]))$weight\n      img <- delete_edges(img,e)\n      if (imin==1){\n        img <- add_edges(img,c(vc[1],rep(paste0('c',df$cell[ii]),each=2),vc[2]), weight=1-tw*diff(c(0,df$t[ii],1)) )\n      }else{\n        img <- add_edges(img,c(vc[1],rep(paste0('c',rev(df$cell[ii])),each=2),vc[2]), weight=1-tw*diff(c(0,df$t[ii],1)) )\n      }\n    }\n    return(img)\n  })\n\n  if (n.mapping > 1) {\n    df.sd <- apply(do.call(cbind,lapply(df.list,function(el)el[rownames(r$R),]$t)),1,sd)\n  }else {df.sd <- NA}\n  df.summary <- cbind(df.list[[1]],t.sd=df.sd)\n\n\n  if (!is.null(emb)){\n    cols <- adjustcolor(df.summary[rownames(r$R),]$color,0.2); names(cols) <- rownames(r$R)\n    plotppt(r,emb,cex.col=cols, tree.col = r$pp.info$color,cex.main=0.5, cex.title=1,cex.tree=1,lwd.tree=1)\n  }\n\n  r$cell.summary <- df.summary\n  r$cell.info <- df.list\n  r$img.list <- img.list\n  #r$mg <- mg;\n  return(invisible(r))\n}\n\n\n##' Determine a set of genes significantly associated with the tree\n##' @param r pptree object\n##' @param X expressinon matrix of genes (row) vs cells (column)\n##' @param fdr.cut FDR (Benjamini-Hochberg adjustment) cutoff on significance; significance if FDR < fdr.cut\n##' @param A.cut cmplitude cutoff on significance; significance if A > A.cut\n##' @param st.cut cutoff on stability (fraction of mappings with significant (fdr,A) pair) of association; significance, significance if A > A.cut\n##' @param summary show plot of amplitude vs FDR of each gene's association. By default FALSE.\n##' @param subtree restrict statistical assesment to a subtree\n##' @return modified pptree object with a new field r$stat.association that includes pvalue, amplitude, fdr, stability and siginificane (TRUE/FALSE) of gene associations\n##' @export\ntest.associated.genes <- function(r,X,n.map=1,n.cores=20,spline.df=3,fdr.cut=1e-4,A.cut=1,st.cut=0.8,summary=FALSE,subtree=NA, ...) {\n  if (is.null(r$root)) {stop(\"assign root first\")}\n  if (is.null(r$cell.summary) | is.null(r$cell.info)) {stop(\"project cells onto the tree first\")}\n  X <- X[,intersect(colnames(X),rownames(r$cell.summary))]\n  if (sum(!colnames(X) %in% rownames(r$cell.summary)) > 0) {stop( paste(\"Expression matrix X contains cells not mapped onto the tree, e.g. cell\",colnames(X)[!colnames(X) %in% rownames(r$cell.summary)][1]) )}\n  if (n.map < 0 | n.map > length(r$cell.info)) {stop(\"n.map should be more than 0 and less than number of mappings\")}\n\n  genes <- rownames(X)\n  subseg <- unique(r$cell.summary$seg);\n  if (!is.na(subtree)) {subseg <- subtree$segs}\n  # for every gene\n  gtl <- lapply(1:n.map,function(ix){\n    print(paste(\"mapping\",ix,\"of\",n.map))\n    if (n.map==1){ inf <- r$cell.summary}else{\n      inf <- r$cell.info[[ix]]\n    }\n    gt <- do.call(rbind,mclapply(genes,function(gene) {\n      #sdf <- inf; sdf$exp <- X[gene,rownames(inf)]\n      sdf <- inf[inf$seg%in%subseg,]; sdf$exp <- X[gene,rownames(sdf)]#[inf$seg%in%subseg]\n      # time-based models\n      mdl <- tapply(1:nrow(sdf),as.factor(sdf$seg),function(ii) {\n        # TODO: adjust df according to branch length?\n        m <- mgcv::gam(exp~s(t,k=spline.df),data=sdf[ii,],familly=gaussian())\n        rl <- list(d=deviance(m),df=df.residual(m))\n        rl$p <- predict(m);\n        return(rl)\n      })\n      mdf <- data.frame(do.call(rbind,lapply(mdl,function(x) c(d=x$d,df=x$df))))\n      # background model\n      odf <- sum(mdf$df)-nrow(mdf); # correct for multiple segments\n      m0 <- mgcv::gam(exp~1,data=sdf,familly=gaussian())\n      if (sum(mdf$d)==0){ fstat <- 0}else{\n        fstat <- (deviance(m0) - sum(mdf$d))/(df.residual(m0)-odf)/(sum(mdf$d)/odf)\n      }\n      pval <-  pf(fstat,df.residual(m0)-odf,odf,lower.tail = FALSE);#1-pf(fstat,df.residual(m0)-odf,odf,lower.tail = T);\n      pr <- unlist(lapply(mdl,function(x) x$p))\n      return(c(pval=pval,A=max(pr)-min(pr)))\n    },mc.cores=n.cores,mc.preschedule=T))\n    gt <- data.frame(gt); rownames(gt) <- genes\n    gt$fdr <- p.adjust(gt$pval,method=\"BH\")\n    gt\n  })\n\n  stat.association <- data.frame(cbind( apply(do.call(cbind,lapply(gtl,function(gt)gt$pval)),1,median),\n                                        apply(do.call(cbind,lapply(gtl,function(gt)gt$A)),1,median),\n                                        apply(do.call(cbind,lapply(gtl,function(gt)gt$fdr)),1,median),\n                                        apply(do.call(cbind,lapply(gtl,function(gt) gt$fdr < fdr.cut & gt$A > A.cut )),1,sum)/length(gtl)\n  ))\n  rownames(stat.association) <- genes; colnames(stat.association) <- c(\"pval\",\"A\",\"fdr\",\"st\")\n  stat.association$sign <- stat.association$fdr < fdr.cut & stat.association$A > A.cut & stat.association$st > st.cut\n\n  # plot amplitude vs FDR and color genes that were idenfitied as significantly associated with the tree\n  if (summary==TRUE){\n    par(mfrow=c(1,1),mar=c(4.5,4.5,1,1))\n    plot(stat.association$A,stat.association$fdr,xlab=\"Amplitude\",ylab=\"FDR, log\",log=\"y\",pch=19,cex=0.5,\n         col=adjustcolor( ifelse(stat.association$sign==TRUE,\"red\",\"black\") ,0.4),cex.lab=1.5)\n    legend(\"bottomleft\", legend=c( paste(\"DE,\",sum(stat.association$sign)), paste(\"non-DE,\",sum(!stat.association$sign))),\n           col=c(\"red\", \"black\"), bty=\"n\",pch=19,cex=1,pt.cex=1)\n  }\n  if (is.na(subtree)){\n    r$stat.association <- stat.association\n    return(r)\n  }else{\n    return(stat.association)\n  }\n}\n\n##' Model gene expression levels as a function of tree positions.\n##' @param r pptree object\n##' @param X expressinon matrix of genes (rows) vs cells (columns)\n##' @param n.map number of probabilistic cell-to-tree mappings to use\n##' @param method method of modeling. Currently only splines with option 'ts' are supported.\n##' @param knn use expression averaging among knn cells\n##' @param gamma stringency of penalty.\n##' @return modified pptree object with new fields r$fit.list, r$fit.summary and r$fit.pattern. r$fit.pattern contains matrix of fitted gene expression levels\n##' @export\nfit.associated.genes <- function(r,X,n.map=1,n.cores=20,method=\"ts\",knn=1,gamma=1.5) {\n  if (is.null(r$root)) {stop(\"assign root first\")}\n  if (is.null(r$cell.summary) | is.null(r$cell.info)) {stop(\"project cells onto the tree first\")}\n  X <- X[,intersect(colnames(X),rownames(r$cell.summary))]\n  if (sum(!colnames(X) %in% rownames(r$cell.summary)) > 0) {stop( paste(\"Expression matrix X contains cells not mapped onto the tree, e.g. cell\",colnames(X)[!colnames(X) %in% rownames(r$cell.summary)][1]) )}\n  if (n.map < 0 | n.map > length(r$cell.info)) {stop(\"n.map should be more than 0 and less than number of mappings\")}\n  if ( is.null(r$stat.association) ) {stop(\"identiy significantly associated genes using test.associated.genes()\")}\n\n\n  #gtl <- lapply(1:n.map,function(ix){\n  #  print(paste(\"mapping\",ix,\"of\",n.map))\n  #  if (n.map==1){ inf <- r$cell.summary}else{\n  #    inf <- r$cell.info[[ix]]\n  #  }\n\n  if (method==\"ts\"){\n    gtl <- fit.ts(r,X,n.map,n.cores,gamma,knn)\n  }else if (method==\"sf\"){\n    gtl <- t.fit.sf(r,X,n.map,n.cores,gamma)\n  }else if (method==\"av\"){\n    gtl <- t.fit.av(r,X,n.map,n.cores)\n  }else{stop(\"please choose correct method name\")}\n  #})\n\n\n  ft.summary <- matrix(0,nrow=nrow(gtl[[1]]),ncol=ncol(gtl[[1]])); rownames(ft.summary) <- rownames(gtl[[1]]); colnames(ft.summary) <- colnames(gtl[[1]])\n  if (length(gtl)>=1){\n    for (k in 1:length(gtl)){\n      #indx <- unlist(lapply(1:nrow(r$cell.summary),function(i) {\n      #  #ind <- rownames(r$cell.info[[k]])[r$cell.info[[k]]$seg==r$cell.summary$seg[i]]\n      #  #ind[which.min(abs(r$cell.info[[k]][ind,]$t-r$cell.summary$t[i]))]\n      #  ind <- rownames(r$cell.summary)[r$cell.summary$seg==r$cell.summary$seg[i]]\n      #  ind[which.min(abs(r$cell.summary[ind,]$t-r$cell.summary$t[i]))]\n      #}))\n      ft.summary <- ft.summary + gtl[[k]]#[,indx]\n    }\n  }\n  ft.summary <- ft.summary/length(gtl)\n  #colnames(ft.summary) <- rownames(r$cell.summary)\n  r$fit.list <- gtl\n  r$fit.summary <- ft.summary\n  r$fit.pattern <- classify.genes(r)\n  print(table(r$fit.pattern))\n\n  return(r)\n}\n\n\n##' Model gene expression levels as a brancing spline function of tree positions.\n##' @param r pptree object\n##' @param X expressinon matrix of genes (rows) vs cells (columns)\n##' @param n.map number of probabilistic cell-to-tree mappings to use\n##' @param knn use expression averaging among knn cells\n##' @param gamma stringency of penalty.\n##' @return matrix of fitted gene expression levels to the tree\n##' @export\nfit.ts <- function(r,X,n.map,n.cores,gamma=1.5,knn=1) {\n  ix <- 1\n  img = r$img.list[[ix]];\n  root = r$root\n  tips = r$tips[r$tips != root]\n  branches.ll = do.call(rbind,lapply(tips, function(tip){\n    b = get.shortest.paths(img,from=as.character(root),to=as.character(tip))$vpath[[1]]$name\n    b = b[grepl(\"^c\",b)]\n    ind <- paste('c',r$cell.info[[ix]]$cell,sep=\"\") %in% b\n    cbind( ids=rownames(r$cell.info[[ix]])[ind], r$cell.info[[ix]][ind,],branch=rep( which(tips==tip),length(b)) )\n  }))\n  # calculate knn for each vertex along the tree\n  for (v in r$pp.info$PP){img <- delete_vertices(img,as.character(v))}\n  dst.tree <- distances(img,v=V(img),to=V(img));\n  dst.tree <- dst.tree[ paste(\"c\",r$cell.summary$cell,sep=\"\"),paste(\"c\",r$cell.summary$cell,sep=\"\") ]\n  rownames(dst.tree) <- colnames(dst.tree) <- rownames(r$cell.summary)\n  dst.tree[dst.tree <= knn] <- 1; dst.tree[dst.tree > knn] <- 0\n\n  gtl <- lapply(1:n.map,function(ix){\n    print(paste(\"fit gene expression for mapping\",ix))\n    img = r$img.list[[ix]];\n    root = r$root\n    tips = r$tips[r$tips != root]\n    branches = do.call(rbind,lapply(tips, function(tip){\n      b = get.shortest.paths(img,from=as.character(root),to=as.character(tip))$vpath[[1]]$name\n      b = b[grepl(\"^c\",b)]\n      ind <- paste('c',r$cell.info[[ix]]$cell,sep=\"\") %in% b\n      cbind( ids=rownames(r$cell.info[[ix]])[ind], r$cell.info[[ix]][ind,],branch=rep( which(tips==tip),length(b)) )\n    }))\n\n    #branches.ll <- branches\n    genes <- intersect(rownames(X),rownames(r$stat.association)[r$stat.association$sign])\n    gt <- do.call(rbind,mclapply(genes,function(gene) {\n      expr.fitted <- unlist(lapply(unique(branches$branch),function(br){\n        branches1 <- branches[branches$branch==br,]\n        expr <- X[gene,as.character(branches1$ids)]\n        #gene.fit1 = gam( expr ~ s( branches1$time,k=length(branches1$time),bs=\"ts\"),knots=list(branches1$time) )\n        tt <- branches1$t\n        #tt <- 1:length(tt)\n        gene.fit1 = mgcv::gam( expr ~ s(tt,bs=\"ts\"),gamma=gamma)\n        #ggplot()+geom_point(aes(tt,expr))+geom_line(aes(tt,gene.fit1$fitted.values))\n        td <- data.frame(matrix(branches.ll[branches.ll$branch==br,]$t,nrow=sum(branches.ll$branch==br)));\n        rownames(td) <- branches.ll[branches.ll$branch==br,]$ids; colnames(td) <- \"tt\"\n        predict(gene.fit1,td )\n      }))\n\n      # old version - averaging along shared branches\n      #for( cell in names(which(table(branches.ll$ids) > 1))){\n      #  expr.fitted[branches.ll$ids==cell] <- mean(expr.fitted[branches.ll$ids==cell])\n      #}\n\n      # new version - knn smoothing, where knns are estimated along the tree.\n      expr.fitted <- (dst.tree[names(expr.fitted),names(expr.fitted)] %*% expr.fitted) / (apply(dst.tree[names(expr.fitted),names(expr.fitted)],1,sum))\n      expr.fitted <- expr.fitted[,1]\n      return(expr.fitted[!duplicated(names(expr.fitted))])\n    },mc.cores = n.cores))\n    rownames(gt) <- genes\n    return(gt)\n  })\n  return(gtl)\n}\n\n\n\n##' Classify tree-associated genes\n##'\n##' Tree-associated genes are classified in branch-monotonous, transiently expressed and having complex patterns.\n##' @param r tree\n##' @param X expressinon matrix of genes (rows) vs cell (columns)\n##' @param cutoff expression in local optimum should be higher/lower than both terminal branch values by cutoff.\n##' @return vector of predicted classification for fitted genes.\n##' @export\nclassify.genes <- function(r,n.cores=20,cutoff=0.2) {\n  if (is.null(r$fit.summary)) {stop(\"fit gene expression to the tree first\")}\n  a <- do.call(cbind,lapply(unique(r$cell.summary$seg),function(seg){\n    seg.summary <- r$cell.summary[r$cell.summary$seg==seg,]\n    tt <- r$fit.summary[,rownames(seg.summary)][,order(seg.summary$t)]\n    # calculate number of inner local optima\n    apply(tt,1,function(x) {\n      res <- loc.opt(x)\n      if ( sum(!is.na(res))==0 ){0}else{nrow(res)}\n    })\n  }))\n  apply(a,1,function(v){\n    if (sum(v)==0) {return(\"branch-monotonous\")}else\n      if (sum(v)==1) {return(\"transiently expressed\")}else\n        if (sum(v)>1) {return(\"complex patterns\")}\n  })\n}\n\n##' Identify all local optima for a time series data\n##' @name loc.opt\n##' @param series - time series data\n##' @param cutoff - expression in local optimum should be on cutoff higher/lower than nearby local optima. This parameter allows to eliminate small local optimas that are likely artifacts\n##' @return data frame containing type of local optima (min/max) and time index.\n##' @export\nloc.opt <- function(series,cutoff=0.1){\n  dx <- diff(series)\n  cand <- (-dx[1:(length(dx)-1)]*dx[2:length(dx)]) > 0\n  # remove multiple rupture-related optima\n  cand[1:(length(cand)-1)][cand[1:(length(cand)-1)]&cand[2:length(cand)]] <- FALSE\n  if (sum(cand)>0){\n    cand <- c(TRUE,cand,TRUE)\n    ds <- diff(series[cand])\n    opt.type <- unlist(lapply(1:(sum(cand)-2),function(i){\n      if (ds[i] > cutoff & (-ds[i+1]) > cutoff ) {\n        \"max\"\n      }else if (ds[i] < -cutoff & (-ds[i+1]) < -cutoff ){\n        \"min\"\n      }else{\n        NA\n      }\n    }))\n    if ( sum(!is.na(opt.type))>0  ){\n      opt.inf <- data.frame(cbind( opt.type[!is.na(opt.type)],as.numeric(which(cand))[2:(sum(cand)-1)][!is.na(opt.type)]),stringsAsFactors=FALSE)\n      colnames(opt.inf) <- c(\"type\",\"index\"); opt.inf$index <- as.numeric(opt.inf$index)\n      return(opt.inf)\n    }\n  }\n  return(NA)\n}\n\n\n##' Visualize branching trajectories of a particular gene.\n##' @param r pptree object\n##' @param gene gene name\n##' @param X matrix with a single row containing a gene expression levels (could be a vector of gene's expression). Columns of X reflect gene names.\n##' @param cex.cell size of cells\n##' @param cex.lab size of axis titles\n##' @param cex.axis size of axis labels\n##' @param cex.main size of title showing a gene name\n##' @param lwd.t1 width of the main branching trajectory\n##' @param lwd.t2 width of ensemble trajectories, typically thiner than that of main trajectory.\n##' @param lwd.erbar width of error bars for uncertainty of cell pseudotime assignment\n##' @param subtree visualise trajectory along a given subtree\n##' @export\nvisualise.trajectory = function(r,gene,X,cex.cell=0.3,cex.lab=2,cex.axis=1.5,cex.main=1,lwd.erbar=0.0,lwd.t1=3,lwd.t2=0.2,switch.point=NA,subtree=NA){\n\n  if (is.null(dim(X))){\n    Xgene <- X\n  }else{\n    if ( gene %in% rownames(X) == FALSE ) {stop(\"gene is not in matrix X\")}\n    Xgene <- X[gene,]\n  }\n  Xgene <- Xgene[intersect(names(Xgene),rownames(r$cell.summary))]\n  if ( sum(!names(Xgene)%in%rownames(r$cell.summary)) > 0 ) {stop(\"matrix/vector X does not contain some cells used to recostruct tree\")}\n\n\n  segs <- unique(r$cell.summary$seg)\n  # restrict considered segments to subtree if given\n  if (!is.na(subtree)){\n    segs <- intersect(segs,subtree$seg)\n  }\n\n  par(mar=c(5,5,3,1))\n  # draw cells\n  ind <- r$cell.summary$seg%in%segs\n  plot(r$cell.summary$t[ind],Xgene[rownames(r$cell.summary)][ind],type = \"n\",\n       xlab=\"pseudotime\",ylab=\"expression\",cex.axis=cex.axis,cex.lab=cex.lab,main=gene,font.main=3,cex.main=cex.main)\n  grid(5,5,lwd=1.5)\n  points(r$cell.summary$t[ind],Xgene[rownames(r$cell.summary)][ind],col=adjustcolor(r$cell.summary$color[ind],0.5),pch=19,cex=cex.cell)\n  # draw error bars of pseudotime uncertainty if given\n  if ( sum(!is.na(r$cell.summary$t.sd))>0 ){\n    segments( r$cell.summary$t[ind]-r$cell.summary$t.sd[ind], Xgene[rownames(r$cell.summary)][ind], r$cell.summary$t[ind]+r$cell.summary$t.sd[ind], y1 = Xgene[rownames(r$cell.summary)][ind],\n              col=adjustcolor(r$cell.summary$color[ind],0.1),lwd=lwd.erbar)\n  }\n  # draw ensemble of sampled trajectries if given\n  if (length(r$fit.list)>1){\n    for (j in 2:length(r$fit.list)){\n      for(seg in segs ){\n        #ind <- r$cell.info[[j]]$seg == seg\n        #t.ord <- order(r$cell.info[[j]]$t[ind])\n        #lines(r$cell.info[[j]]$t[ind][t.ord],r$fit.list[[j]][gene,rownames(r$cell.info[[j]])][ind][t.ord],\n        #      col=adjustcolor(r$cell.info[[j]]$color[ind][t.ord],0.4),lwd=lwd.t2)\n\n        ind <- r$cell.summary$seg == seg\n        t.ord <- order(r$cell.summary$t[ind])\n        lines(r$cell.summary$t[ind][t.ord],r$fit.list[[j]][gene,rownames(r$cell.summary)][ind][t.ord],\n              col=adjustcolor(r$cell.summary$color[ind][t.ord],0.4),lwd=lwd.t2)\n\n      }\n    }\n  }\n  # draw likelihood trajectory\n  for(seg in segs ){\n    ind <- r$cell.summary$seg == seg\n    t.ord <- order(r$cell.summary$t[ind])\n    lines(r$cell.summary$t[ind][t.ord],r$fit.summary[gene,rownames(r$cell.summary)][ind][t.ord],\n          col=r$cell.summary$color[ind][t.ord],lwd=lwd.t1)\n  }\n  if (!is.na(switch.point)){\n    abline(v=switch.point,lty=1,lwd=3,col=adjustcolor(\"black\",0.5))\n  }\n  # connect boundary cells from different branches\n  g <- r$img.list[[1]]\n  for (seg in unique(r$cell.summary$seg)){\n\n    ind <- r$cell.summary$seg==seg\n    c2.name <- rownames(r$cell.summary[ind,])[which.min(r$cell.summary$t[ind])]\n    c2 <- r$cell.summary$cell[ind][which.min(r$cell.summary$t[ind])]\n    c2.seg <- r$cell.summary$seg[ind][which.min(r$cell.summary$t[ind])]\n\n    c2.path <- names(shortest_paths(g,r$root,paste(\"c\",c2,sep=\"\") )$vpath[[1]])\n    c2.path <- c2.path[unlist(lapply(1:length(c2.path),function(i) grepl(\"c\",c2.path[i])))]\n    c2.path <- as.numeric(unlist(lapply(strsplit(c2.path,\"c\"),function(x)x[2])))\n    ind <- r$cell.summary$cell %in% c2.path & r$cell.summary$cell != c2 #& !(r$cell.summary$seg %in% r$cell.summary[c2.name,]$seg)\n\n    if (sum(ind)>0){\n      c1.name <- rownames(r$cell.summary[ind,])[which.max(r$cell.summary$t[ind])]\n      segments(r$cell.summary[c(c1.name),]$t,r$fit.summary[gene,c(c1.name)],r$cell.summary[c(c2.name),]$t,r$fit.summary[gene,c(c2.name)],\n               col=r$cell.summary[c2.name,]$color,lwd=lwd.t1)\n    }\n  }\n\n}\n\n\n##' Visualize clusters of genes using heatmap and consensus tree-projected pattern.\n##' @param r pptree object\n##' @param emb cells embedding\n##' @param clust a vector of cluster numbers named by genes\n##' @param n.best show n.best the most representative genes on the heatmap for each cluster\n##' @param best.method use method to select the most representative genes. Current options: \"pca\" selects genes with the highest loading on pc1 component reconstructed using genes from a cluster, \"cor\" selects genes that have the highest average correlation with other genes from a cluster.\n##' @param cex.gene size of gene names\n##' @param cex.cell size of cells on embedding\n##' @param cex.tree width of line of tree on embedding\n##' @param reclust whether to reorder cells inside individual clusters on heatmap according to hierarchical clustering using Ward linkage and 1-Pearson as a distance between genes. By default is FALSE.\n##' @param subtree visualize clusters for a given subtree\n##' @export\nvisualise.clusters <-function(r,emb,clust,n.best=4,best.method=\"cor\",cex.gene=1,cex.cell=0.1,cex.tree=2,reclust=FALSE,subtree=NA){\n\n\n  if ( sum(!names(clust)%in%rownames(r$fit.summary))>0) {stop( paste(\"Expression is not fitted for\",sum(!names(clust)%in%rownames(r$fit.summary)),\"gene\" ))}\n  if (best.method!=\"pca\" & best.method!=\"cor\") {stop(paste(\"incorrect best.method option\",best.method) )}\n  tseg <- unlist(lapply( unique(r$cell.summary$seg),function(seg)mean(r$cell.summary$t[r$cell.summary$seg==seg]))); names(tseg) <-  unique(r$cell.summary$seg)\n  tseg <- tseg[as.character(r$cell.summary$seg)]\n\n  emat <- r$fit.summary[names(clust),rownames(r$cell.summary)][,order(tseg,r$cell.summary$t)]\n  emat <- t(apply(emat,1,function(x) (x-mean(x))/sd(x) ))\n  cols <- r$cell.summary$col[order(tseg,r$cell.summary$t)]\n  subcells = TRUE; if (!is.na(subtree)){subcells <- r$cell.summary$seg[order(tseg,r$cell.summary$t)]%in%subtree$seg}\n  k <- length(unique(clust))\n  genes.show <- unlist(lapply(1:k,function(i){\n    n <- n.best; if ( sum(clust==i) < n) {n <- sum(clust==i)}\n    if (best.method==\"pca\"){\n      pr <- pca(t(emat[clust==i,]),center = TRUE, scale = \"uv\")\n      pr.best <- rep(i,n); names(pr.best) <- names(sort(pr@loadings[,1],decreasing = T))[1:n]\n      return(pr.best)\n    }else if (best.method==\"cor\"){\n      cr <- cor(t(emat[clust==i,]))\n      cr.best <- rep(i,n); names(cr.best) <- names(sort(apply(cr,1,mean),decreasing = TRUE))[1:n]\n      return(cr.best)\n    }\n  }))\n\n  nf <- layout( matrix(unlist(lapply(1:k,function(i) 5*(i-1)+c(1,2,3,1,4,5))),2*k,3, byrow=T),respect = T,width=c(1,1,0.1),heights=rep(c(0.1,1),k) )\n  #layout.show(nf)\n  for (cln in 1:k){\n    # draw cluster-wise pattern\n    par(mar=c(0.3,0.1,0.0,0.2))\n    plotppt(r,emb,pattern.cell = apply(emat[clust==cln,],2,mean),cex.main=cex.cell,cex.tree = cex.tree,lwd.tree = 0.1,subtree=subtree)\n    # draw color-scheme for branches\n    #par(mar=c(0.0,0.2,0.1,2))\n    par(mar=c(0.0,0.0,0.0,0))\n    col.ind <- 1:length(unique(cols)); names(col.ind) = unique(cols)\n    image( t(rbind( col.ind[cols[subcells]] )),axes=FALSE,col=(unique(cols[subcells])) )\n    box()\n\n    par(mar=c(0.0,0.0,0.0,0))\n    plot(0.2,0.2,ylim=c(0.05,0.95),xlim=c(0,1),xaxt='n',yaxt='n',pch='',ylab='',xlab='',bty='n')\n\n    # recluster genes if necessary\n    gns <- names(clust)[clust==cln]\n    if (reclust==TRUE){\n      dst.cor <- 1-cor(t(emat[gns,]))\n      hclust.cor <- hclust(as.dist(dst.cor),method=\"ward.D\")\n      gns <- gns[hclust.cor$order]\n    }\n\n    #par(mar=c(0.2,0.2,0.0,2))\n    par(mar=c(0.3,0.0,0.0,0))\n    image( t(emat[gns,subcells]),axes=FALSE,col=colorRampPalette(c(\"blue\",\"grey80\",\"red\"))(n = 60))\n    #axis( 4, at=seq(0,1,length.out=sum(clust==cln)),col.axis=\"black\", labels=gns,hadj=0.1,xaxt=\"s\",cex.axis=1.5,font = 3,las= 1,tick=FALSE)\n    box()\n\n    gns[! gns %in% names(genes.show)[genes.show==cln] ] <- \"\"\n    ### calculate coordinates of genes.show with QP\n    coord <- which( names(clust)[clust==cln] %in% names(genes.show)[genes.show==cln] )/sum(clust==cln)\n    del <- 1/(sum(genes.show==cln))#0.1\n    Dmat <- diag(1,length(coord),length(coord))\n    dvec <- rep(0,length(coord))\n    Amat <- matrix(0,nrow= 3*length(coord)-1,ncol=length(coord)); bvec = rep(0,3*length(coord)-1)\n    for (i in 1:(length(coord)-1)){Amat[i,i] <- -1; Amat[i,i+1] <- 1; bvec[i] <- del - (coord[i+1]-coord[i])}\n    for (i in 1:(length(coord))){j <- i+length(coord)-1; Amat[j,i] <- 1; bvec[j] <- -coord[i]+0 }\n    for (i in 1:(length(coord))){j <- i+2*length(coord)-1; Amat[j,i] <- -1; bvec[j] <- coord[i]-1}\n    qp = solve.QP(Dmat, dvec, t(Amat), bvec, meq=0, factorized=FALSE)\n    coord_new = qp$solution + coord\n    par(mar=c(0.3,0,0,0))\n    plot(0.2,0.2,ylim=c(0.0,1),xlim=c(0,1),xaxt='n',yaxt='n',pch='',ylab='',xlab='',bty='n')\n    axis(side = 4, at = coord_new,lwd=0.0,lwd.ticks=0,font=3,cex.axis=cex.gene,labels=gns[gns!=\"\"],tck=0.0,hadj=0.0,line=-0.9,las=1)\n    for (i in 1:length(coord)){\n      arrows( 0,coord[i],1,coord_new[i],length=0.0,lwd=0.7 )\n    }\n    ###\n  }\n\n}\n\n\n\n##' Determine genes differentially upregulated after bifurcation point\n##' @param r pptree object\n##' @param mat expression matrix of genes (rows) and cells (columnts)\n##' @param root a principal point of fork root\n##' @param leaves vector of two principal points of fork leaves\n##' @param genes optional set of genes to estimate association with fork\n##' @return summary statistics of size effect and p-value of association with bifurcaiton fork.\n##' @export\ntest.fork.genes <- function(r,mat,matw=NULL,root,leaves,genes=rownames(mat),n.cores=30) {\n  sdf <- r$cell.pseudotime;\n  g <- graph.adjacency(r$B>0,mode=\"undirected\")\n  vpath = get.shortest.paths(g,root,leaves)\n  interPP = intersection(vpath$vpath[[1]],vpath$vpath[[2]])\n  which.max(r$pp.info[interPP,]$time)\n  vpath = get.shortest.paths(g, r$pp.info[interPP,]$PP[which.max(r$pp.info[interPP,]$time)],leaves)\n  brcells = do.call(rbind,lapply( 1:length(vpath$vpath), function(i){\n    x=vpath$vpath[[i]]\n    segs = as.numeric(names(table(r$pp.info[x,]$seg))[table(r$pp.info[x,]$seg)>1])\n    return(cbind(r$cell.summary[r$cell.summary$seg %in% segs,],i))\n  }))\n  # for every gene\n  gtl <- do.call(rbind,mclapply(genes,function(gene) {\n    brcells$exp <- mat[gene,rownames(brcells)]\n    #plot(brcells$t,brcells$exp,col=brcells$color)\n    if (is.null(matw)) {brcells$w = 1\n    }else {brcells$w <- matw[gene,r$cells][as.integer(gsub(\"c\",\"\",brcells$node))]}\n    # time-based models\n    m <- mgcv::gam(exp ~ s(t)+s(t,by=as.factor(i))+as.factor(i),data=brcells,familly=gaussian(),weights=brcells$w)\n    return( c(mean(brcells$exp[brcells$i==2])-mean(brcells$exp[brcells$i==1]) ,summary(m)$p.pv[2]) )\n  },mc.cores=n.cores,mc.preschedule=T));\n  colnames(gtl) = c(\"effect\",\"p\"); rownames(gtl) = genes; gtl = as.data.frame(gtl)\n  return(gtl);\n}\n\n\n\n# construct consensus trajectory either by using principle points (type=\"PP\") or by using cells (type=\"cell\")\nt.consensus.trajectory = function(genes,z.ensemble,type=\"PP\"){\n\n  gene.info = do.call(rbind,lapply(1:length(z.ensemble),function(i){\n    r = z.ensemble[[i]];rownames(r$fitting$pp.fitted) =  rownames(r$fitting$expr.fitted)\n    #data.frame(cbind(r$cell.pseudotime,expr=r$fitting$expr.fitted[genes,names(r$cells)[r$cells]][r$cell.pseudotime$cell]),tree=i)\n    data.frame(cbind(r$cell.pseudotime),tree=i)\n  }))\n\n  gene.info.consensus = cbind(aggregate(gene.info[,\"time\"],by=list(gene.info$cell), mean ),\n                              aggregate(gene.info[,\"time\"],by=list(gene.info$cell), sd )[-1],\n                              aggregate(gene.info[,c(\"seg\")],by=list(gene.info$cell), FUN = function(x) names(sort(table(x),decreasing=TRUE))[1] )[-1],\n                              aggregate(gene.info[,c(\"color\")],by=list(gene.info$cell), FUN = function(x) names(sort(table(x),decreasing=TRUE))[1] )[-1],\n                              aggregate(gene.info[,c(\"color\")],by=list(gene.info$cell), FUN = function(x) sort(table(x),decreasing=TRUE)[1] )[-1]  )\n  names(gene.info.consensus) = c(\"PP\",\"time\",\"time_sd\",\"seg\",\"color\",\"fraction\")\n  gene.info.consensus$seg = as.numeric(gene.info.consensus$seg)\n  gene.info.matrix = matrix(0,nrow(z.ensemble[[1]]$fitting$expr.fitted),ncol(z.ensemble[[1]]$fitting$expr.fitted))\n  for (i in 1:length(z.ensemble)){\n    gene.info.matrix = gene.info.matrix + z.ensemble[[i]]$fitting$expr.fitted[,names(z.ensemble[[i]]$cells)[z.ensemble[[i]]$cells]]#[z.ensemble[[i]]$cell.pseudotime$cell]]\n  }\n  gene.info.matrix = gene.info.matrix / length(z.ensemble)\n\n\n  PPinfo = z.ensemble[[1]]$PPinfo\n  PPmatrix = matrix( 0,nrow(z.ensemble[[1]]$fitting$pp.fitted),ncol(z.ensemble[[1]]$fitting$pp.fitted)  )\n  rownames(PPmatrix) = rownames(z.ensemble[[1]]$fitting$pp.fitted)\n  for (i in 1:length(z.ensemble)){\n    PPmatrix = PPmatrix + z.ensemble[[i]]$fitting$pp.fitted\n  }\n  PPmatrix = PPmatrix / length(z.ensemble)\n\n  if (type==\"PP\")\n    list(info = PPinfo, expr = PPmatrix)\n  else if (type==\"cell\")\n    list(info = gene.info.consensus, expr = gene.info.matrix)\n}\n\n\n\n##' Extract subtree of the tree\n##' @param r ppt.tree object\n##' @param nodes set tips or internal nodes (bifurcations) to extract subtree\n##' @return list of segments comprising a subtree.\n##' @export\nextract.subtree = function(r,nodes){\n  g <- graph.adjacency(r$B>0,mode=\"undirected\")\n  if ( sum(!nodes%in%V(g)) > 0 ) {stop(paste(\"the following nodes are not in the tree:\",nodes[!nodes%in%V(g)],collapse = \" \") )}\n  if ( sum( degree(g)==2 & (V(g) %in% nodes) ) > 0 ) {stop( paste(\"the following nodes are nethier terminal nor fork:\",nodes[nodes %in% V(g)[V(g)==2] ],collapse=\" \") )}\n  vpath = get.shortest.paths(g,nodes[1],nodes)\n  v = c()\n  for (i in 1:length(vpath$vpath)){\n    v=c(v,unlist(vpath$vpath[[i]]))\n  }\n  v=unique(v)\n  segs = r$pp.info$seg[r$pp.info$PP %in% v]\n  segs = segs[segs %in% names(table(segs))[table(segs) > 1]]\n  #v=v[ r$pp.info[v,]$seg %in% unique(segs)  ] #list( segs = unique(segs), pp = v )\n  list( segs = unique(segs) )\n}\n\n##' Decompose a number by degrees of 2.\n##' @param n number\ndecompose <- function(n){\n  base.binary = c()\n  while (n > 0){\n    x <- as.integer(log2(n))\n    base.binary <- c(base.binary,x)\n    n = n - 2^x\n  }\n  return(base.binary)\n}\n\n\n\n\n",
    "created" : 1555352034866.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3716684012",
    "id" : "3B487632",
    "lastKnownWriteTime" : 1555353014,
    "last_content_update" : 1555353014234,
    "path" : "~/NC/crestree/R/crestree.functions.R",
    "project_path" : "R/crestree.functions.R",
    "properties" : {
    },
    "relative_order" : 14,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}