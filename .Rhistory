qplot( abs(as.numeric(z$DT - (1-zz$DT) )) )
qplot( abs(as.numeric(z$B - zz$B)) )
sum( abs(as.numeric(z$B - zz$B)) == 1 )
str(zz$F)
str(z$F)
qplot( zz$F-z$F )
qplot( as.numeric(zz$F-z$F) )
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=length(nc.cells),W=wgwm[,nc.cells],vi=vi,init=wgm[rownames(wgm),nc.cells],lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
qplot( zz$R-z$R )
qplot( as.numeric(zz$R-z$R) )
qplot( as.numeric(zz$DT-z$DT) )
qplot( as.numeric(zz$B-z$B) )
t.ppt.tree <- function(X,M,W=matrix(1,nrow=nrow(X),ncol=ncol(X)),vi=rep(T,nrow(d2)),init=NULL,lambda=1e1,loc=0, sigma=1,seed=NULL,n.steps=30,cord=TRUE,beta.s1=NULL,beta.s2=NULL) {
require(igraph)
X <- as.matrix(X); W <- as.matrix(W);
# fake per-cell variance param vectors if necessary
if(!is.null(beta.s1)) {
if(length(beta.s1)==1) { beta.s1 <- rep(beta.s1,ncol(X)); beta.s2 <- rep(beta.s2,ncol(X)) }
} else {
if(length(sigma)==1) { sigma <- rep(sigma,ncol(X)) }
if(length(loc)==1) { loc <- rep(loc,ncol(X)) }
}
if(is.null(init)) {
if(!is.null(seed)) {
set.seed(seed);
}
# todo ... smooth the initial points ...
F <- X[,sample(1:ncol(X),M)]; rownames(F) <- NULL; colnames(F) <- NULL;
} else {
F <- init;
}
# row-normalize W
rwm <- matrix(rowSums(W),nrow=nrow(F),ncol(F))
W <- W/rowSums(W)*ncol(W);
# per-step lambda
if(length(lambda)==1) { lambda <- rep(lambda,n.steps) }
# repeat
for(j in 1:n.steps) {
# calculate R
if(cord) { # weighted correlation distance
R <- do.call(rbind,lapply(1:ncol(X),function(i) {
if(!is.null(beta.s1)) {
x <- dbeta((1-matWVCorr(F,X[,i],W[,i]))/2,beta.s1[i],beta.s2[i])
} else {
#x <- exp(-(1-matWVCorr(F,X[,i],W[,i])-loc[i])/sigma[i])
x <- exp(-(pmax(0,1-matWVCorr(F,X[,i],W[,i])-loc[i]))/sigma[i])
}
x[is.na(x) | is.nan(x)] <- 0;
sx <- sum(x);
if(sx>0) {
t(x/sx)
} else {
t(rep(1/length(x),length(x)))
}
}))
#rownames(R) <- colnames(X)
#print(dim(R))
} else { # eucledian
R <- do.call(rbind,lapply(1:ncol(X),function(i) {
x <- exp(-colSums(((F-X[,i]-loc[i])^2)*W[,i])/sigma[i])
x/sum(x);
}))
}
if(cord) { # correlation distance mode
#d <- as.matrix(cor(F))
#bt <- minimum.spanning.tree(graph.adjacency(1-d,weighted=T,mode="undirected"))
#d[d<0] <- 0;
# correlation with exponential decay
#d <- exp(as.matrix(cor(F))*1)
# estimate distance between principal points based on the similarity of their releationships with the cells
#d <- as.matrix(dist(t(R),method='manhattan')); # patchy with realtively close points being completely detached
# recalculate an R matix using relaxed sigma
#       Rp <- do.call(rbind,lapply(1:ncol(X),function(i) {
#           #t(matWVCorr(F,X[,i],W[,i]))
#         x <- (exp(-(1-matWVCorr(F,X[,i],W[,i]-loc[i])/1)))
#         x[is.na(x) | is.nan(x)] <- 0;
#       sx <- sum(x);
#         if(sx>0) {
#           t(x/sx)
#         } else {
#           t(rep(1/length(x),length(x)))
#         }
#       }))
#       Rp <- t(t(Rp)/colSums(Rp))*nrow(Rp)
#       d <- as.matrix(1-cor(R,method="pearson")); # spearman settles very quickly
#       #d <- as.matrix(dist(t(Rp),method='manhattan'));
#       bt <- minimum.spanning.tree(graph.adjacency(d,weighted=T,mode="undirected"))
#       d <- exp(-(1-d)/0.5); #d[d<0] <- 0;
#d <- 1/(d+1)
#browser()
# weighted correlation - note inefficient calculation - only one weight per gene is necessary, not the whole rmw matrix
d <- as.matrix(stats::as.dist(1- .Call("matWCorr", F, rwm, PACKAGE = "scde"),upper=T))
#d <- (1-cor(cor(F,method="spearman"),method="spearman"))^4
#d <- (1-cor(F,method="spearman"))^4
bt <- minimum.spanning.tree(graph.adjacency(d,weighted=T,mode="undirected"))
#d <- 1-d; d[d<0] <- 0;
# eucleadian
#d <- as.matrix(dist(t(F)));
#bt <- minimum.spanning.tree(graph.adjacency(d,weighted=T,mode="undirected"))
#d <- 1/(d+1);
} else { # Euclidean
d <- as.matrix(dist(t(F)));
bt <- minimum.spanning.tree(graph.adjacency(d,weighted=T,mode="undirected"))
#d <- exp(- (d/100));
d <- 1/sqrt(d+1);
}
B <- as.matrix(get.adjacency(bt)) # binary version (e.g. no distance)
# distance-based version
#B <- (d)*as.matrix(get.adjacency(bt))
# standard laplacian
#L <- diag(nrow(B))*rowSums(B)-B
# normalized
#Di2 <- diag(nrow(B))/sqrt(rowSums(B));
#L <- diag(nrow(B)) - Di2 %*% B %*% Di2;
# random walk laplacian
#Di <- diag(nrow(B))/rowSums(B);
#L <- diag(nrow(B)) - Di %*% B;
# custom laplacian
#D <- diag(nrow(B))*rowSums(B);
#x <- rowSums(B); x[x==2]<-1;
#Dm <- diag(nrow(B))/x;
D <- diag(nrow(B))*rowSums(B);
L <- D-B
#D <- diag(nrow(B))*rowSums(B);
#x <- rowSums(B); x[x==2]<-1; Dmi <- diag(nrow(B))/x^(1/2);
#L <- Dmi %*% (D-B) ;
#L <- (D-B) %*% Dmi;
M <- L*lambda[j] + diag(ncol(R))*colSums(R)
# branch penalty
#x <- rowSums(B); x[x==2]<-1; Dmi <- diag(nrow(B))/x^(1/2);
#M <- M %*% Dmi;
old.F <- F;
F <- ((X*W)%*%R) %*% chol2inv(chol(M))
#F <- ((X*W)%*%R) %*% solve(M)
print(str(R))
t.plot.ppt(list(F=F,B=B,R=R,L=L,lambda=lambda[j],sigma=sigma),vi=vi)
cat(j,":")
#cat(sum(abs(old.F-F)))
#if(is.na(sum(abs(old.F-F)/abs(old.F)))) { browser() }
cat(mean(rowSums(abs(old.F-F)/abs(old.F))),"\n")
}
# calculate unscaled R for scoring
if(cord) {
if(!is.null(beta.s1)) {
lRu <- do.call(rbind,lapply(1:ncol(X),function(i) {
t(x <- dbeta((1-matWVCorr(F,X[,i],W[,i]))/2,beta.s1[i],beta.s2[i],log=T))
}))
} else {
lRu <- do.call(rbind,lapply(1:ncol(X),function(i) {
#x <- -(1-matWVCorr(F,X[,i],W[,i])-loc[i])/sigma[i];
t(-(pmax(0,1-matWVCorr(F,X[,i],W[,i])-loc[i]))/sigma[i])
}))
}
} else {
lRu <- do.call(rbind,lapply(1:ncol(X),function(i) {
t(-colSums(((F-X[,i]-loc[i])^2)*W[,i])/sigma[i]);
}))
}
g = graph.adjacency(B,mode="undirected");tips = V(g)[degree(g)==1];forks = V(g)[degree(g)>2]
invisible(list(F=F,B=B,R=R,L=L,DT=d,lambda=lambda,sigma=sigma,n.steps=n.steps,cord=cord,lRu=lRu,M=M,cells=vi,tips=tips,forks=forks))
}
# c
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
qplot( as.numeric(zz$DT-z$DT) )
qplot( as.numeric(zz$R-z$R) )
t.ppt.tree <- function(X,M,W=matrix(1,nrow=nrow(X),ncol=ncol(X)),vi=rep(T,nrow(d2)),init=NULL,lambda=1e1,loc=0, sigma=1,seed=NULL,n.steps=30,cord=TRUE,beta.s1=NULL,beta.s2=NULL) {
require(igraph)
X <- as.matrix(X); W <- as.matrix(W);
# fake per-cell variance param vectors if necessary
if(!is.null(beta.s1)) {
if(length(beta.s1)==1) { beta.s1 <- rep(beta.s1,ncol(X)); beta.s2 <- rep(beta.s2,ncol(X)) }
} else {
if(length(sigma)==1) { sigma <- rep(sigma,ncol(X)) }
if(length(loc)==1) { loc <- rep(loc,ncol(X)) }
}
if(is.null(init)) {
if(!is.null(seed)) {
set.seed(seed);
}
# todo ... smooth the initial points ...
F <- X[,sample(1:ncol(X),M)]; rownames(F) <- NULL; colnames(F) <- NULL;
} else {
F <- init;
}
# row-normalize W
rwm <- matrix(rowSums(W),nrow=nrow(F),ncol(F))
W <- W/rowSums(W)*ncol(W);
# per-step lambda
if(length(lambda)==1) { lambda <- rep(lambda,n.steps) }
# repeat
for(j in 1:n.steps) {
# calculate R
if(cord) { # weighted correlation distance
R <- do.call(rbind,lapply(1:ncol(X),function(i) {
if(!is.null(beta.s1)) {
x <- dbeta((1-matWVCorr(F,X[,i],W[,i]))/2,beta.s1[i],beta.s2[i])
} else {
#x <- exp(-(1-matWVCorr(F,X[,i],W[,i])-loc[i])/sigma[i])
x <- exp(-(pmax(0,1-matWVCorr(F,X[,i],W[,i])-loc[i]))/sigma[i])
}
x[is.na(x) | is.nan(x)] <- 0;
sx <- sum(x);
if(sx>0) {
t(x/sx)
} else {
t(rep(1/length(x),length(x)))
}
}))
#rownames(R) <- colnames(X)
#print(dim(R))
} else { # eucledian
R <- do.call(rbind,lapply(1:ncol(X),function(i) {
x <- exp(-colSums(((F-X[,i]-loc[i])^2)*W[,i])/sigma[i])
x/sum(x);
}))
}
if(cord) { # correlation distance mode
#d <- as.matrix(cor(F))
#bt <- minimum.spanning.tree(graph.adjacency(1-d,weighted=T,mode="undirected"))
#d[d<0] <- 0;
# correlation with exponential decay
#d <- exp(as.matrix(cor(F))*1)
# estimate distance between principal points based on the similarity of their releationships with the cells
#d <- as.matrix(dist(t(R),method='manhattan')); # patchy with realtively close points being completely detached
# recalculate an R matix using relaxed sigma
#       Rp <- do.call(rbind,lapply(1:ncol(X),function(i) {
#           #t(matWVCorr(F,X[,i],W[,i]))
#         x <- (exp(-(1-matWVCorr(F,X[,i],W[,i]-loc[i])/1)))
#         x[is.na(x) | is.nan(x)] <- 0;
#       sx <- sum(x);
#         if(sx>0) {
#           t(x/sx)
#         } else {
#           t(rep(1/length(x),length(x)))
#         }
#       }))
#       Rp <- t(t(Rp)/colSums(Rp))*nrow(Rp)
#       d <- as.matrix(1-cor(R,method="pearson")); # spearman settles very quickly
#       #d <- as.matrix(dist(t(Rp),method='manhattan'));
#       bt <- minimum.spanning.tree(graph.adjacency(d,weighted=T,mode="undirected"))
#       d <- exp(-(1-d)/0.5); #d[d<0] <- 0;
#d <- 1/(d+1)
#browser()
# weighted correlation - note inefficient calculation - only one weight per gene is necessary, not the whole rmw matrix
d <- as.matrix(stats::as.dist(1- .Call("matWCorr", F, rwm, PACKAGE = "scde"),upper=T))
#d <- (1-cor(cor(F,method="spearman"),method="spearman"))^4
#d <- (1-cor(F,method="spearman"))^4
bt <- minimum.spanning.tree(graph.adjacency(d,weighted=T,mode="undirected"))
#d <- 1-d; d[d<0] <- 0;
# eucleadian
#d <- as.matrix(dist(t(F)));
#bt <- minimum.spanning.tree(graph.adjacency(d,weighted=T,mode="undirected"))
#d <- 1/(d+1);
} else { # Euclidean
d <- as.matrix(dist(t(F)));
bt <- minimum.spanning.tree(graph.adjacency(d,weighted=T,mode="undirected"))
#d <- exp(- (d/100));
d <- 1/sqrt(d+1);
}
B <- as.matrix(get.adjacency(bt)) # binary version (e.g. no distance)
# distance-based version
#B <- (d)*as.matrix(get.adjacency(bt))
# standard laplacian
#L <- diag(nrow(B))*rowSums(B)-B
# normalized
#Di2 <- diag(nrow(B))/sqrt(rowSums(B));
#L <- diag(nrow(B)) - Di2 %*% B %*% Di2;
# random walk laplacian
#Di <- diag(nrow(B))/rowSums(B);
#L <- diag(nrow(B)) - Di %*% B;
# custom laplacian
#D <- diag(nrow(B))*rowSums(B);
#x <- rowSums(B); x[x==2]<-1;
#Dm <- diag(nrow(B))/x;
D <- diag(nrow(B))*rowSums(B);
L <- D-B
#D <- diag(nrow(B))*rowSums(B);
#x <- rowSums(B); x[x==2]<-1; Dmi <- diag(nrow(B))/x^(1/2);
#L <- Dmi %*% (D-B) ;
#L <- (D-B) %*% Dmi;
M <- L*lambda[j] + diag(ncol(R))*colSums(R)
# branch penalty
#x <- rowSums(B); x[x==2]<-1; Dmi <- diag(nrow(B))/x^(1/2);
#M <- M %*% Dmi;
old.F <- F;
F <- ((X*W)%*%R) %*% chol2inv(chol(M))
#F <- ((X*W)%*%R) %*% solve(M)
print(str(R))
t.plot.ppt(list(F=F,B=B,R=R,L=L,lambda=lambda[j],sigma=sigma),vi=vi)
cat(j,":")
#cat(sum(abs(old.F-F)))
#if(is.na(sum(abs(old.F-F)/abs(old.F)))) { browser() }
cat(mean(rowSums(abs(old.F-F)/abs(old.F))),"\n")
}
# calculate unscaled R for scoring
if(cord) {
if(!is.null(beta.s1)) {
lRu <- do.call(rbind,lapply(1:ncol(X),function(i) {
t(x <- dbeta((1-matWVCorr(F,X[,i],W[,i]))/2,beta.s1[i],beta.s2[i],log=T))
}))
} else {
lRu <- do.call(rbind,lapply(1:ncol(X),function(i) {
#x <- -(1-matWVCorr(F,X[,i],W[,i])-loc[i])/sigma[i];
t(-(pmax(0,1-matWVCorr(F,X[,i],W[,i])-loc[i]))/sigma[i])
}))
}
} else {
lRu <- do.call(rbind,lapply(1:ncol(X),function(i) {
t(-colSums(((F-X[,i]-loc[i])^2)*W[,i])/sigma[i]);
}))
}
g = graph.adjacency(B,mode="undirected");tips = V(g)[degree(g)==1];forks = V(g)[degree(g)>2]
invisible(list(F=F,B=B,R=R,L=L,DT=d,lambda=lambda,sigma=sigma,n.steps=n.steps,cord=cord,lRu=lRu,M=M,cells=vi,tips=tips,forks=forks))
}
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=length(nc.cells),W=wgwm[,nc.cells],vi=vi,init=wgm[rownames(wgm),nc.cells],lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
qplot( as.numeric(zz$DT-z$DT) )
qplot( as.numeric(zz$R-z$R) )
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=length(nc.cells),vi=vi,init=wgm[rownames(wgm),nc.cells],lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
qplot( as.numeric(zz$DT-z$DT) )
source("/d0/home/solrust/NC/DynTree/R/crestree.functions.R")
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
source("/d0/home/solrust/NC/DynTree/R/crestree.functions.R")
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
qplot( as.numeric(zz$DT-z$DT) )
qplot(zz$DT[,1],z$Dt[,1])
qplot(zz$DT[,1],z$DT[,1])
qplot(zz$DT[,2],z$DT[,2])
qplot(zz$DT[2,],z$DT[2,])
qplot(zz$DT[200,],z$DT[200,])
qplot(zz$DT[2000,],z$DT[2000,])
qplot(zz$DT[400,],z$DT[400,])
qplot(zz$DT[400,]-z$DT[400,])
qplot( as.numeric(zz$DT[,]-z$DT[,]) )
qplot( zz$DT[,5],zz$DT[5,] )
source("/d0/home/solrust/NC/DynTree/R/crestree.functions.R")
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=length(nc.cells),W=wgwm[,nc.cells],vi=vi,init=wgm[rownames(wgm),nc.cells],lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
qplot( zz$DT[,5],zz$DT[5,] )
qplot( as.numeric(zz$DT[,]-z$DT[,]) )
qplot( (zz$DT[,]-z$DT[,]) )
qplot( (zz$DT[,]-z$DT[,])==0 )
head( (zz$DT[,]-z$DT[,])==0 )
qplot( (zz$R[,]-z$R[,]) )
qplot( as.numeric(zz$R[,]-z$R[,]) )
qplot( as.numeric(zz$DT[,]-z$DT[,]) )
qplot( as.numeric(zz$F[,]-z$F[,]) )
scde:::matWCorr
str(z$F)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=300,W=wgwm[,nc.cells],vi=vi,init=wgm[rownames(wgm),nc.cells],lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
str(zz$F)
str(zz$R)
str(zz$DT)
str(zz$B)
str(zz$L)
str(zz$R)
rm(zz)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=300,W=wgwm[,nc.cells],vi=vi,init=wgm[rownames(wgm),nc.cells],lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=300,W=wgwm[,nc.cells],vi=vi,lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
str(zz$R)
str(zz$B)
str(zz$F)
str(rwm)
rwm <- matrix(rowSums(W),nrow=nrow(F),ncol(F))
str(W)
str(rwm)
source("/d0/home/solrust/NC/DynTree/R/crestree.functions.R")
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=300,W=wgwm[,nc.cells],vi=vi,lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=1, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
str(z$DT)
str(zz$DT)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=length(nc.cells),init=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells],vi=vi,lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=1,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
str(zz$DT)
plot(z$DT[1,])
qplot(z$DT[1,])
qplot(zz$DT[1,])
qplot(z$DT[1,],zz$DT[1,])
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=10, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=sample(1,1),plot=TRUE)
lambda <- 250
sig <- 0.04
zz <- t.ppt.tree(X=wgm[rownames(wgm),nc.cells],M=length(nc.cells),init=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells],vi=vi,lambda=lambda,loc=0, sigma=sig,seed=1,
n.steps=10,cord=TRUE,beta.s1=NULL,beta.s2=NULL)
str(z$R)
str(zz$R)
plot(z$R[,1],zz$R[,1])
0.04/0.1565862
#λ=250,σ=0.04; subsampling = 90%
lambda <- 250
sig <- 0.255
z.ensemble <- bootstrap.ppt(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=as.integer(length(nc.cells)*0.9), cex.tree=0.3, lambda=lambda, sigma=sig,plot=FALSE,
n.samples=10,n.cores=20, seed=NULL,replace=FALSE)
plotpptl(z.ensemble,emb, cols=adjustcolor("grey",alpha=0.1),alpha=0.02, lwd=1)
plotpptl(z.ensemble,emb, cols=adjustcolor("grey",alpha=0.1),alpha=0.05, lwd=1)
z.ensemble <- bootstrap.ppt(X=wgm[rownames(wgm),nc.cells],emb=emb, metrics="cosine",M=as.integer(length(nc.cells)*0.9), cex.tree=0.3, lambda=lambda, sigma=sig,plot=FALSE,
n.samples=10,n.cores=20, seed=NULL,replace=FALSE)
plotpptl(z.ensemble,emb, cols=adjustcolor("grey",alpha=0.1),alpha=0.05, lwd=1)
lambda <- 250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=10, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=2,plot=TRUE)
plotppt(z,emb,tips=FALSE,cex.tree = 0.1,cex.main=0.2,lwd.tree = 1)
0.04/0.1565862
0.04/0.1565862
lambda <- 300#250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=10, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=2,plot=TRUE)
plotppt(z,emb,tips=FALSE,cex.tree = 0.1,cex.main=0.2,lwd.tree = 1)
length(nc.cells)*0.9
dim(z.ensemble1[[1]]$R)
lambda <- 250#250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=550, err.cut = 5e-3,cex.tree=0.3,
n.steps=10, lambda=lambda, sigma=sig,init=wgm[rownames(wgm),nc.cells],
seed=1,plot=TRUE)
lambda <- 250#250
sig <- 0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=20, lambda=lambda, sigma=sig,#init=wgm[rownames(wgm),nc.cells],
seed=1,plot=TRUE)
lambda <- 250#250
sig <- 0.3#0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=20, lambda=lambda, sigma=sig,#init=wgm[rownames(wgm),nc.cells],
seed=1,plot=TRUE)
lambda <- 250#250
sig <- 0.3#0.04/0.1565862 #0.26
z <- ppt.tree(X=wgm[rownames(wgm),nc.cells],W=wgwm[,nc.cells], emb=emb, metrics="cosine",M=length(nc.cells), err.cut = 5e-3,cex.tree=0.3,
n.steps=50, lambda=lambda, sigma=sig,#init=wgm[rownames(wgm),nc.cells],
seed=1,plot=TRUE)
devtools::use_package("Rcpp") # Defaults to imports
devtools::use_package("inline") # Defaults to imports
devtools::use_package("RcppArmadillo") # Defaults to imports
plot(emb,col=clcol)
unbiased = local({load("/d0/home/solrust/NC/unbiased_clustering_11_18.RData"); environment()})
plot(emb,col=unbiased$clcol)
saveRDS(list(fpm = fpm, wgm = wgm,wgwm=wgwm,emb = emb,clcol = unbiased$clcol,varinfo = varinfo,nc.cells=nc.cells,
"/d0/home/solrust/NC/for_package_new.rds")
saveRDS(list(fpm = fpm, wgm = wgm,wgwm=wgwm,emb = emb,clcol = unbiased$clcol,varinfo = varinfo,nc.cells=nc.cells),
"/d0/home/solrust/NC/for_package_new.rds")
q()
q()
